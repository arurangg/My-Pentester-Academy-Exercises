#!/usr/bin/env python

import sys
import socket
import select
import Queue
from signal import SIGINT, signal


def sig_handler(signal_number, interrupted_stack_frame):
        print "\nSIGINT received..Bye Bye"
	sys.exit(0)

signal(SIGINT, sig_handler)

tcpSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
tcpSocket.setblocking(0)
tcpSocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

if len(sys.argv) < 2:
	port = 1337
else:
	port = int(sys.argv[1])

tcpSocket.bind(('', port))

tcpSocket.listen(10)

# The arguments to select() are three lists containing communication channels to monitor.
# The first is a list of the objects to be checked for incoming data to be read,
# the second contains objects that will receive outgoing data when there is room in their buffer,
# and the third those that may have an error (usually a combination of the input and output channel objects).
# The next step in the server is to set up the lists containing input sources and output destinations.
# to be passed to select().

sockets_to_read = [tcpSocket]
sockets_to_write = []

# Connections are added to and removed from these lists by the server main loop. Since this version of the
# server is going to wait for a socket to become writable before sending any data
# (instead of immediately sending the reply), each output connection needs a queue to act as a buffer for
# the data to be sent through it.

message_queues = {}

while sockets_to_read:
	rd, wr, ex = select.select(sockets_to_read, sockets_to_write, sockets_to_read )

# The "rd" sockets represent three possible cases. If the socket is the main "server" socket,
# the one being used to listen for connections, then the "readable" condition means it is ready to accept
# another incoming connection. In addition to adding the new connection to the list of inputs to monitor,
# this section sets the client socket to not block.
	for s in rd:
		if s is tcpSocket:
			clientSocket, (clientIP,sock) = s.accept()
			print "Received connection from "+clientIP
			clientSocket.setblocking(0)
			sockets_to_read.append(clientSocket)
			message_queues[clientSocket] = Queue.Queue()
#The next case is an established connection with a client that has sent data.
		else:
			data = s.recv(1024)
			if len(data):
				print "Received data from ",clientIP,": ",data
				message_queues[s].put(data)
				if s not in sockets_to_write:
					sockets_to_write.append(s)
# A readable socket without data available is from a client that has disconnected,
# and the stream is ready to be closed.
			else:
				print "Connection with ",clientIP," closed.."
				if s in sockets_to_write:
					socket_to_write.remove(s)
				sockets_to_read.remove(s)
				s.close()
				del message_queues[s]
# There are fewer cases for the writable connections. If there is data in the queue for a connection,
# the next message is sent. Otherwise, the connection is removed from the list of output connections 
# so that the next time through the loop select() does not indicate that the socket is ready to send data.
	for s in wr:
		try:
			next_msg = message_queues[s].get_nowait()
		except Queue.Empty:
			sockets_to_write.remove(s)
		else:
			s.send(next_msg)
